{
    "contents" : "#----------------------------------------------#\n# R code for plotting/demonstrations of nROUSE #\n#----------------------------------------------#\n\n# Index\n# Lookup - 01:  nROUSE_predictions\n# Lookup - 02:  nROUSE_demonstration\n\n# Lookup - 01\n#' Predictions from the nROUSE model\n#'\n#' Generates a plot of the predicted accuracy over different \n#' prime durations and types for the nROUSE model (output can \n#' be generated as well).\n#'\n#' @param primeDurations a vector of prime durations between \n#'   17 and 2000 ms.\n#' @param primeTypes a character vector with up to 4 types of prime: \n#'   'Target', 'Foil', 'Neither', or 'Both'.\n#' @param design a vector with the duration (in ms) of the target flash,\n#'   the target mask, and the choice options.\n#' @param opt a logical vector indicating if the predicted accuracies \n#'   latencies should be returned, and if a plot should be generated.\n#' @param prm an optional named vector for the parameters of the \n#'   nROUSE model.\n#' @return A list consisting of a matrix of predicted accuracies by \n#'   prime duration and type, and an array with the predicted perceptual \n#'   identification latencies for the target and foil by prime duration \n#'   and prime type.\n#' @export\n\nnROUSE_predictions = function( primeDurations = c( 17,50,150,400,2000 ),\n                    primeTypes = c('Target','Foil','Neither','Both'),\n                    design = c( 50, 450, 500 ),\n                    opt = c( F, T ),\n                    prm = NULL ) {\n  \n  # Default parameters\n  param = c( Fe = .25, N = .0302, L = .15, \n             D = .324, R = .022, I = .9844, \n             Th = .15, Ta = 1.0, SV = .0294, \n             SO = .0609, SS = .015 )\n  \n  # Check if parameter values should be changed\n  if ( length( prm ) > 0 ) {\n    \n    selPar = names(prm)\n    \n    for (i in 1:length(selPar)) {\n      chk = names(param) == selPar[i]\n      if ( sum(chk) == 1 ) \n        param[ chk ] = prm[i]\n    }\n    \n  }\n  \n  # Sort prime duratiosn\n  primeDurations = sort( primeDurations );\n  \n  # Check if prime types are admissable\n  chk = c('Target','Foil','Neither','Both')\n  if ( sum(primeTypes %in% chk) < length(primeTypes) ) \n    stop('Check character vector for prime types.')\n  \n  # Matrices to store output\n  Accuracy = matrix( NA, length( primeDurations ),\n                     length( primeTypes ) )\n  colnames( Accuracy ) = primeTypes;\n  rownames( Accuracy ) = as.character( primeDurations )\n  \n  Latency = array( NA, dim=c( length( primeDurations ),\n                              length( primeTypes ),\n                              2 ) )\n  \n  # Simulate nROUSE\n  for ( pt in 1:length( primeTypes ) ) {\n    for ( pd in 1:length( primeDurations ) ) {\n      pres = c( primeDurations[pd], design )\n      \n      if (primeTypes[pt] == 'Target') prmT = c(2,0)\n      if (primeTypes[pt] == 'Foil') prmT = c(0,2)\n      if (primeTypes[pt] == 'Neither') prmT = c(0,0)\n      if (primeTypes[pt] == 'Both') prmT = c(1,1)\n      \n      sim = simulate_nROUSE( pres, prmT, param )\n      \n      Accuracy[pd,pt] = sim$Latencies[3]\n      Latency[pd,pt,] = sim$Latencies[1:2]\n      \n    }\n  }\n  \n  # Plot results\n  if (opt[2]) {\n    \n    clrs = c( Target = 'orange', \n              Foil = 'red', \n              Neither = 'blue', \n              Both = 'purple' )\n    \n    xl = c( 10, max( primeDurations ) )\n    \n    plot( log(xl), c(0,1), type = 'n', xaxt = 'n', \n          yaxt = 'n', xlab = ' ', ylab = ' ', \n          bty = 'l' )\n    xa = c(10,100,1000,5000)\n    axis( 1, log( xa[ xa <= max(xl) ] ), \n          xa[ xa <= max(xl) ], cex.axis = 1.5 )\n    mtext('Prime duration (log ms)',side=1,cex=1.5,\n          line = 2.25)\n    axis(2,seq(0,1,.25),cex.axis=1.5)\n    mtext('Accuracy',side=2,cex=1.5,\n          line = 2.25)\n    abline( h = .5, lty = 2, lwd = 2 )\n    mtext('nROUSE predictions', side = 3, line = 1, \n          cex = 1.5 )\n    \n    whchClr = c()\n    for ( pt in 1:length( primeTypes ) ) {\n      \n      clr = clrs[ names(clrs) %in% primeTypes[pt] ]\n      whchClr = c( whchClr, clr )\n      \n      lines( log( primeDurations ), Accuracy[,pt], col = clr, \n             lwd = 2 )\n      points( log( primeDurations ), Accuracy[,pt], bg = clr, \n             pch = 21, cex = 1.2 )\n      \n    }\n    legend('bottomleft',primeTypes, fill = whchClr, bty = 'n', \n           cex = 1.5 )\n    \n  }\n  \n  \n  if (opt[1]) return( list( Accuracy = Accuracy, Latency = Latency ) )\n}\n                   \n# Lookup - 02\n#' Demonstration of the nROUSE model.\n#'\n#' Generates a plot of the activation at the highest level of the \n#' neural network (i.e. semantic-lexical) for the target and foil \n#' representations under different prime types and an inputted \n#' prime duration.\n#'\n#' @param primeTypes a character vector with up to 4 types of prime: \n#'   'Target', 'Foil', 'Neither', or 'Both'.\n#' @param design a vector with the duration (in ms) of the target flash,\n#'   the target mask, and the choice options.\n#' @param prm an optional named vector for the parameters of the \n#'   nROUSE model.\n#' @details The user will receive a prompt to input a prime duration. \n#'   The function will then generate a plot showing the time course \n#'   of activation for the target/foil representations for the \n#'   set of prime types. The predicted accuracies and the difference \n#'   distribution from which these accuracies are derived are shown \n#'   on the right.\n#' @export\n\nnROUSE_demonstration = function(primeTypes = c('Target','Foil',\n                                               'Neither','Both'),\n                                design = c( 50, 450, 500 ), \n                                prm = NULL ) {\n  \n  # Default parameters\n  param = c( Fe = .25, N = .0302, L = .15, \n             D = .324, R = .022, I = .9844, \n             Th = .15, Ta = 1.0, SV = .0294, \n             SO = .0609, SS = .015 )\n  \n  # Check if parameter values should be changed\n  if ( length( prm ) > 0 ) {\n    \n    selPar = names(prm)\n    \n    for (i in 1:length(selPar)) {\n      chk = names(param) == selPar[i]\n      if ( sum(chk) == 1 ) \n        param[ chk ] = prm[i]\n    }\n    \n  }\n  \n  cat(\"Prime duration? (17 - 2000)\",\"\\n\")\n  cat(\"Type number (in ms) and hit 'enter'\",\"\\n\")\n  \n  pd = scan(n = 1)\n  td = design[1]\n  md = design[2]\n  cd = design[3]\n  \n  presentations = c( pd, design )\n  \n  pltStr = c()\n  npt = length( primeTypes )\n  pltStr = matrix( rep( 1:length( primeTypes ), each = 8 ),\n                   length( primeTypes ), 8, byrow = T )\n  pltStr = pltStr + 0:(length(primeTypes)-1)\n  pltStr = cbind( pltStr, pltStr[,1:2]+1 )\n\n  layout( pltStr )\n  \n  for (pt in 1:length(primeTypes)) {\n    \n    if (primeTypes[pt] == 'Target') prmT = c(2,0)\n    if (primeTypes[pt] == 'Foil') prmT = c(0,2)\n    if (primeTypes[pt] == 'Neither') prmT = c(0,0)\n    if (primeTypes[pt] == 'Both') prmT = c(1,1)\n    \n    sim = simulate_nROUSE( presentations,\n                           prmT, param );\n    \n    par( mar=c( 3, 3, 2, .5 ) )\n    if ( pt == nrow(pltStr) ) par( mar=c(4,3,1,.5) )\n    \n    yl = max( apply( sim$Activation, 2, max ) )\n    yl = c(0,ceiling(yl*10)/10)\n    xl = nrow(sim$Activation)\n    xl = c(0,xl)\n    plot( xl, yl, type = 'n', bty = 'n', \n          xlab = ' ', ylab = ' ',\n          xaxt = 'n', yaxt = 'n' )\n    abline(h=0,lwd=2)\n    mtext( primeTypes[pt], side = 2, cex = 1.25, line = -.75 )\n    if (pt==nrow(pltStr)) axis(1,round(seq(xl[1],xl[2],length=5)),\n                               tick = F, line = -1, cex.axis = 1.4 )\n    if (pt == 1) {\n      \n      xp = grconvertX( 1, from = \"npc\", to = \"user\" )*.1\n      \n      if ( nrow(pltStr) == 4 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*1.25\n      if ( nrow(pltStr) == 3 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*1.2\n      if ( nrow(pltStr) == 2 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*1.1\n      \n      legend( xp, yp, c('Prime','Target','Mask','Choices'),\n              fill = c('blue','orange','purple','grey'),\n              bty = 'n', cex= 1.4, horiz = T, xpd = T )\n      \n      if ( nrow(pltStr) == 4 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*.15\n      if ( nrow(pltStr) == 3 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*.1\n      if ( nrow(pltStr) == 2 ) \n        yp = grconvertY( 1, from = \"npc\", to = \"user\" )*.05\n      \n      legend( xp, 0 - yp, \n              c('Target activation', 'Foil activation'),\n              fill = c('orange','red'),\n              bty = 'n', cex= 1.4, horiz = T, xpd = T )\n    }\n    \n    for (i in 1:3) segments( cumsum(presentations[1:i])+.5, 0, \n                             cumsum(presentations[1:i])+.5, yl[2], \n                             col = 'grey80' )\n    \n    lines( 1:nrow(sim$Activation),\n           sim$Activation[,1], lwd = 2, col = 'orange' )\n    lines( 1:nrow(sim$Activation),\n           sim$Activation[,2], lwd = 2, col = 'red'  )\n    \n    pck = numeric(2)\n    act = sim$Activation[ (pd+td+md+1):(pd+td+md+cd), ]\n    for (i in 1:2) {\n      pck[i] = which( act[,i] == max( act[,i] ) )\n      segments( pck[i] + (pd+td+md), 0,\n                pck[i] + (pd+td+md), act[pck[i],i], col = 'black',\n                lwd = 2 )\n    }\n    \n    segments( 1, yl[2], pd, yl[2],\n              col = 'blue', lwd = 3 )\n    segments( pd+1, yl[2], \n              pd+td, yl[2],\n              col = 'orange', lwd = 3 )\n    segments( pd+td+1, yl[2], \n              pd+td+md, yl[2],\n              col = 'purple', lwd = 3 )\n    segments( pd+td+md+1, yl[2], \n              pd+td+md+cd, yl[2],\n              col = 'grey', lwd = 3 )\n    \n    mu = diff(sim$Latencies[2:1])\n    sigma = sqrt( sum( exp( param['N']*sim$Latencies[1:2] ) ) )\n    \n    val = seq( -4*sigma, 4*sigma, length = 1000 ) + mu\n    dn = dnorm( val, mu, sigma )\n    \n    par( mar=c(1,.5,.5,3) )\n    plot( dn, val, type = 'n', xlab = ' ', ylab = ' ',\n          yaxt = 'n', xaxt = 'n', lwd = 2, bty = 'n' )\n    \n    sel = val < 0\n    polygon( c(0, dn[sel], 0 ),\n             c( min(val[sel]), val[sel], max(val[sel]) ),\n             col = 'grey', border = 'NA' )\n    lines( dn, val, lwd = 2 )\n    abline( h = 0, lwd = 2, lty = 2 )\n    legend( 'bottom', \n            paste( round( sim$Latencies[3], 2 )*100, '%', sep = '' ),\n            bty = 'n', cex = 1.5 )\n    \n  }\n  mtext('Activation',side=2,outer=T,cex=1.5,line=-1.75)\n  mtext('Duration (ms)',side=1,outer=T,cex=1.5,line=-1.5)\n  mtext('Predicted accuracy',side=4,outer=T,cex=1.5,line=-1.5)\n  \n}\n\n",
    "created" : 1471232009793.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1375334548",
    "id" : "8AF94E2",
    "lastKnownWriteTime" : 1471305586,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/nROUSE/R/Plotting_code.R",
    "project_path" : "R/Plotting_code.R",
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}