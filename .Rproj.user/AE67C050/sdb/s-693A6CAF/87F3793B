{
    "collab_server" : "",
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n\n#include \"RcppArmadillo.h\"\n// [[Rcpp::depends(RcppArmadillo)]]\n\n\n/*\nPurpose:\nC++ code for fast simulation of the nROUSE model (Huber and O'Reilly, \n2003; Reith & Huber, 2017).\n\n// Printing to R console\nRcpp::Rcout << \"Debugging example\" << std::endl;\n\nIndex\nLookup - 01:  subplus\nLookup - 02:  update_nROUSE\nLookup - 03:  simulate_nROUSE\n*/\n\n// Lookup - 01\n// An internal function to calculate when membrane potentials \n// are above a firing threshold.\narma::mat subplus( arma::mat A, double Th ) {\n  \n  arma::mat B( A.n_rows, A.n_cols, arma::fill::ones );\n  B = A - B*Th;\n  \n  B.elem( find( B <= 0.0 ) ).zeros();\n  \n  return( B );\n}\n\n// Lookup - 02\n// An internal function that updates the membrane potential, amplitude, \n// and output for a specified layer in the nROUSE network.\nvoid update_nROUSE( arma::mat& new_mem, arma::mat& new_amp, arma::mat& old_out, \n                    arma::mat inp, arma::mat old_mem, arma::mat old_amp, \n                    double Th, double L, double R, double D, double I, \n                    Rcpp::NumericVector S, int level ) {\n  \n  // Output is above threshold activation multiplied by available \n  // synaptic resources\n  double sums;\n  \n  old_out = subplus( old_mem, Th ) % old_amp;\n  \n  // Initialize matrix for inhibition\n  arma::mat inhibit(1, old_out.n_cols, arma::fill::zeros);\n  if ( level == 1 ) {\n    // Visual inhibition\n    \n    // Prime, target, and mask mutually inhibit each other \n    // (centrally presented)\n    sums = old_out(0,0) + old_out(0,1) + old_out(0,2);\n    for (int i = 0; i < 3; i++) inhibit(0,i) = sums;\n    // Choice words only self inhibit (unique screen location)\n    for (int i = 3; i < 5; i++) inhibit(0,i) = old_out(0,i);\n    \n  } else {\n    // For orthography and semantics, everything inhibits everything\n    \n    sums = accu( old_out );\n    int Tot = old_out.n_cols;\n    for ( int i = 0; i < Tot; i++ ) inhibit(0,i) = sums;\n    \n  }\n  \n  // Define matrix filled with ones\n  arma::mat ones_const( old_mem.n_rows, old_mem.n_cols, arma::fill::ones );\n  \n  // Update membrane potential and synaptic resources\n  new_mem = old_mem + S(level-1)*( inp % ( ones_const - old_mem ) - \n    L*old_mem - \n    I*(inhibit % old_mem) );\n  new_amp = old_amp + S(level-1)*( R*(ones_const - old_amp) - D*old_out );\n  \n  // Keep things within bounds\n  new_mem.elem( find( new_mem < 0.0 ) ).zeros();\n  new_mem.elem( find( new_mem > 1.0 ) ).ones();\n  new_amp.elem( find( new_amp < 0.0 ) ).zeros();\n  new_amp.elem( find( new_amp > 1.0 ) ).ones();\n  \n}\n\n//' The nROUSE model\n//'\n//' Function to simulate the predictions of the nROUSE model (Huber \n//' and O'Reilly, 2003; Reith & Huber, 2017) for perceptual \n//' identification latencies and forced-choice accuracy.\n//'\n//' @param presentations A vector giving the duration (in ms) of \n//'   the prime, the target, the mask, and the choice alternatives.\n//' @param primeInput A vector of two elements used to set the type \n//'   of prime. For instance, [2,0] indicates a double prime for \n//'   targets, while [0,1] indicates a single prime for foils.\n//' @param param A vector giving the values for the parameters.\n//'  \\describe{\n//'    \\item{\\code{param[1]}}{Semantic to orthographic feedback scalar}\n//'    \\item{\\code{param[2]}}{Noise constant}\n//'    \\item{\\code{param[3]}}{Constant leak current}\n//'    \\item{\\code{param[4]}}{Synaptic depletion rate}\n//'    \\item{\\code{param[5]}}{Recovery rate}\n//'    \\item{\\code{param[6]}}{Inhibition constant}\n//'    \\item{\\code{param[7]}}{Activation threshold}\n//'    \\item{\\code{param[8]}}{Temporal attention}\n//'    \\item{\\code{param[9]}}{Integration time constant (Visual)}\n//'    \\item{\\code{param[10]}}{Integration time constant (Orthographic)}\n//'    \\item{\\code{param[10]}}{Integration time constant (Semantic)}\n//'     }\n//'\n//' @section References:\n//' Huber, D. E., & O'Reilly, R. C. (2003). Persistence and \n//'   accommodation in short-term priming and other perceptual \n//'   paradigms: Temporal segregation through synaptic depression. \n//'   Cognitive Science, 27(3), 403-430.\n//'   \n//' Rieth, C. A., & Huber, D. E. (2017). Comparing different \n//'   kinds of words and word-word relations to test an habituation \n//'   model of priming. Cognitive Psychology, 95, 79-104.\n//'   DOI: https://doi.org/10.1016/j.cogpsych.2017.04.002\n//'\n//' @examples\n//' # Define duration (in ms) for prime, target, mask, and choices\n//' presentations = c( 17, 50, 450, 500 )\n//' # Set a double prime for targets\n//' primeInput = c(2,0)\n//' # Simulate model with default parameters\n//' sim = simulate_nROUSE( presentations, primeInput )\n//'\n//' @export\n// [[Rcpp::export]]\nRcpp::List simulate_nROUSE( Rcpp::NumericVector presentations, \n                            Rcpp::NumericVector primeInput, \n                            Rcpp::NumericVector param = \n                              Rcpp::NumericVector::create(\n                                .25, .0302, .15, .324, .022, \n                                .9844, .15, 1.0, .0294, .0609, \n                                .015 ) ) {\n  // Duration of prime\n  int PrimeDur = presentations(0);\n  // Duration of target flash\n  int TarDur = presentations(1);\n  // Duration of target mask\n  int MaskDur = presentations(2);\n  // Duration of choice options\n  int ChoiceDur = presentations(3);\n  \n  double Fe = param(0); // Semantic to orthographic feedback scalar\n  double N = param(1);  // Noise constant\n  double L = param(2);  // Constant leak current\n  double D = param(3);  // Synaptic depletion rate\n  double R = param(4);  // Recovery rate\n  double I = param(5);  // Inhibition constant\n  double Th = param(6); // Activation threshold\n  double Ta = param(7); // Temporal attention\n  Rcpp::NumericVector S(3);\n  S(0) = param(8);      // Integration time constants at each level\n  S(1) = param(9);\n  S(2) = param(10);\n  \n  // Set these as variables to be stored\n  arma::mat Latency( 1, 2, arma::fill::zeros );\n  double acc;\n  \n  int VPR = 0;  // Visual prime\n  int VTR = 1;  // Visual target\n  int VMK = 2;  // Visual mask\n  int VTRC = 3; // Visual target choice\n  int VFLC = 4; // Visual foil choice\n  \n  // Assignments for orthographic and semantic layers\n  int TARG = 0; // Target\n  int FOIL = 1; // Foil\n  \n  // Weight matrices\n  arma::mat VisOrth( 5, 2, arma::fill::zeros );\n  VisOrth( 0, 0 ) = primeInput(0);\n  VisOrth( 0, 1 ) = primeInput(1);\n  VisOrth( 1, 0 ) = 1.0;\n  VisOrth( 3, 0 ) = 1.0;\n  VisOrth( 4, 1 ) = 1.0;\n  \n  // Identity matrix for weights\n  arma::mat OrthSem(2,2,arma::fill::eye);\n  // Same identity matrix for feedback\n  arma::mat SemOrth(2,2,arma::fill::eye);\n  \n  // Determine time when choices are presented\n  int SOA = PrimeDur + TarDur + MaskDur;\n  // Duration of entire trial\n  int TrialDur = SOA + ChoiceDur;\n  \n  // Create matrix to track membrane potential and activation\n  Rcpp::NumericMatrix firing_rate( TrialDur, 2 );\n  \n  // Initialize neural variables\n  \n  // Visual layer\n  arma::mat mem_vis( 1, 5, arma::fill::zeros );\n  arma::mat amp_vis( 1, 5, arma::fill::ones );\n  arma::mat out_vis( 1, 5, arma::fill::zeros );\n  \n  // Orthographic layer\n  arma::mat mem_orth( 1, 2, arma::fill::zeros );\n  arma::mat amp_orth( 1, 2, arma::fill::ones );\n  arma::mat out_orth( 1, 2, arma::fill::zeros );\n  \n  // Semantic-lexical layer\n  arma::mat mem_sem( 1, 2, arma::fill::zeros );\n  arma::mat amp_sem( 1, 2, arma::fill::ones );\n  arma::mat out_sem( 1, 2, arma::fill::zeros );\n  \n  // Needed to check for peak output\n  arma::mat old_sem( 1, 2, arma::fill::zeros );\n  \n  // Initialize input\n  arma::mat inp_vis( 1, 5);\n  \n  // Update layers every ms\n  for ( int t = 1; t <= TrialDur; t++ ) {\n    \n    // Present prime\n    if ( t == 1 ) {\n      inp_vis.zeros();\n      inp_vis(0,VPR) = 1.0;\n    }\n    // Present target\n    if ( t == PrimeDur + 1 ) {\n      inp_vis.zeros();\n      inp_vis(0,VTR) = Ta;\n    }\n    // Present mask\n    if ( t == PrimeDur + TarDur + 1 ) {\n      inp_vis.zeros();\n      inp_vis(0,VMK) = 1.0;\n    }\n    // Present choices\n    if ( t == SOA+1 ) {\n      inp_vis.zeros();\n      inp_vis(0,VTRC) = 1.0;\n      inp_vis(0,VFLC) = 1.0;\n    }\n    \n    // Update visual layer\n    arma::mat new_mem_vis( 1, 5, arma::fill::zeros );\n    arma::mat new_amp_vis( 1, 5, arma::fill::zeros );\n    update_nROUSE( new_mem_vis, new_amp_vis, out_vis, \n                   inp_vis, mem_vis, amp_vis, \n                   Th, L, R, D, I, S, 1 );\n    \n    // Determine input from visual layer\n    arma::mat inp_orth = out_vis*VisOrth;\n    inp_orth = inp_orth + Fe*( out_sem*SemOrth );\n    \n    // Update orthographic layer\n    arma::mat new_mem_orth( 1, 5, arma::fill::zeros );\n    arma::mat new_amp_orth( 1, 5, arma::fill::zeros );\n    update_nROUSE( new_mem_orth, new_amp_orth, out_orth, \n                   inp_orth, mem_orth, amp_orth, \n                   Th, L, R, D, I, S, 2 );\n    \n    // Determine input to lexical-semantic layer\n    arma::mat inp_sem = out_orth*OrthSem;\n    \n    // Update semantic-lexical layer\n    arma::mat new_mem_sem( 1, 5, arma::fill::zeros );\n    arma::mat new_amp_sem( 1, 5, arma::fill::zeros );\n    update_nROUSE( new_mem_sem, new_amp_sem, out_sem, \n                   inp_sem, mem_sem, amp_sem, \n                   Th, L, R, D, I, S, 3 );\n    \n    // Perceptual decision process\n    \n    // The +50 gives things a chance to get going before peak \n    // activation is checked\n    if ( t > SOA + 50 ) {\n      for ( int tf = 0; tf < 2; tf++ ) {\n        // Step through index for target and foil\n        if ( ( out_sem(tf) < old_sem(tf) ) && \n             ( Latency(0,tf) == 0 ) ) {\n          // Check for peak activation\n          Latency(0,tf) = t - SOA;\n        }\n      }\n      old_sem = out_sem;\n    }\n    \n    // Swap old variables with new variables\n    mem_vis = new_mem_vis;\n    amp_vis = new_amp_vis;\n    mem_orth = new_mem_orth;\n    amp_orth = new_amp_orth;\n    mem_sem = new_mem_sem;\n    amp_sem = new_amp_sem;\n    \n    firing_rate(t-1,0) = out_sem(0,0);\n    firing_rate(t-1,1) = out_sem(0,1);\n  }\n  \n  // Calculate accuracy\n  // Average difference between target and foil latency\n  double mean_diff = Latency(0,FOIL) - Latency(0,TARG);\n  // Variance of difference between target and foil latency\n  double var_diff = accu( exp( N * Latency.row(0) ) );\n  \n  acc = 1.0 - R::pnorm( 0.0, mean_diff, pow(var_diff,0.5), 1, 0 );\n  \n  if ( ( Latency(0,TARG) == 0 ) && \n       ( Latency(0,FOIL) > 0 ) ) {\n    // Target never launched\n    acc = 0.0;\n  }\n  if ( ( Latency(0,TARG) > 0 ) && \n       ( Latency(0,FOIL) == 0 ) ) {\n    // Foil never launched\n    acc = 1.0;\n  }\n  if ( ( Latency(0,TARG) == 0 ) && \n       ( Latency(0,FOIL) == 0 ) ) {\n    // Neither launched\n    acc = 0.5;\n  }\n  \n  Rcpp::NumericVector out(3);\n  out(0) = Latency(0,0);\n  out(1) = Latency(0,1);\n  out(2) = acc;\n  out.names() = Rcpp::CharacterVector::create(\n    \"Target\", \"Foil\", \"Accuracy\");\n  \n  colnames(firing_rate) = Rcpp::CharacterVector::create(\"Target\", \"Foil\");\n  \n  // Create a list of output\n  return Rcpp::List::create( \n    Rcpp::Named(\"Latencies\", out ),\n    Rcpp::Named(\"Activation\", firing_rate ) );\n}",
    "created" : 1509810298679.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3250326558",
    "id" : "87F3793B",
    "lastKnownWriteTime" : 1509806694,
    "last_content_update" : 1509806694,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/nROUSE/src/nROUSE_functions.cpp",
    "project_path" : "src/nROUSE_functions.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}