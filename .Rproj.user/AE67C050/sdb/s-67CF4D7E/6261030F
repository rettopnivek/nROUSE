{
    "contents" : "#include \"RcppArmadillo.h\"\n\n// [[Rcpp::export]]\narma::mat subplus( arma::mat A, double Th ) {\n  \n  arma::mat B( A.n_rows, A.n_cols, arma::fill::ones );\n  B = A - B*Th;\n  \n  B.elem( find( B <= 0.0 ) ).zeros();\n  \n  return( B );\n}\n\n// [[Rcpp::export]]\nvoid update_nROUSE( arma::mat& new_mem, arma::mat& new_amp, arma::mat& old_out, \n                    arma::mat inp, arma::mat old_mem, arma::mat old_amp, \n                    double Th, double L, double R, double D, double I, \n                    Rcpp::NumericVector S, int level ) {\n  \n  // Output is above threshold activation multiplied by available \n  // synaptic resources\n  double sums;\n  \n  old_out = subplus( old_mem, Th ) % old_amp;\n  \n  // Initialize matrix for inhibition\n  arma::mat inhibit(1, old_out.n_cols, arma::fill::zeros);\n  if ( level == 1 ) {\n    // Visual inhibition\n    \n    // Prime, target, and mask mutually inhibit each other \n    // (centrally presented)\n    sums = old_out(0,0) + old_out(0,1) + old_out(0,2);\n    for (int i = 0; i < 3; i++) inhibit(0,i) = sums;\n    // Choice words only self inhibit (unique screen location)\n    for (int i = 3; i < 5; i++) inhibit(0,i) = old_out(0,i);\n    \n  } else {\n    // For orthography and semantics, everything inhibits everything\n    \n    sums = accu( old_out );\n    for ( int i = 0; i < old_out.n_cols; i++ ) inhibit(0,i) = sums;\n    \n  }\n  \n  // Define matrix filled with ones\n  arma::mat ones_const( old_mem.n_rows, old_mem.n_cols, arma::fill::ones );\n  \n  // Update membrane potential and synaptic resources\n  new_mem = old_mem + S(level-1)*( inp % ( ones_const - old_mem ) - \n    L*old_mem - \n    I*(inhibit % old_mem) );\n  new_amp = old_amp + S(level-1)*( R*(ones_const - old_amp) - D*old_out );\n  \n  // Keep things within bounds\n  new_mem.elem( find( new_mem < 0.0 ) ).zeros();\n  new_mem.elem( find( new_mem > 1.0 ) ).ones();\n  new_amp.elem( find( new_amp < 0.0 ) ).zeros();\n  new_amp.elem( find( new_amp > 1.0 ) ).ones();\n  \n}\n\n// [[Rcpp::export]]\nRcpp::List simulate_nROUSE( Rcpp::NumericVector durations, \n                            Rcpp::NumericVector presentations, \n                            Rcpp::NumericVector param, \n                            Rcpp::NumericVector primeInput ) {\n  \n  // Duration of target flash\n  int TarDur = presentations(0);\n  // Duration of target mask\n  int MaskDur = presentations(1);\n  // Duration of choice options\n  int ChoiceDur = presentations(2);\n  \n  double Fe = param(0); // Semantic to orthographic feedback scalar\n  double N = param(1);  // Noise constant\n  double L = param(2);  // Constant leak current\n  double D = param(3);  // Synaptic depletion rate\n  double R = param(4);  // Recovery rate\n  double I = param(5);  // Inhibition constant\n  double Th = param(6); // Activation threshold\n  Rcpp::NumericVector S(3);\n  S(0) = param(7);      // Integration time constants at each level\n  S(1) = param(8);\n  S(2) = param(9);\n  \n  // Set these as variables to be stored\n  arma::mat Latency( durations.size(), 2, arma::fill::zeros );\n  Rcpp::NumericVector acc( durations.size() );\n  \n  int VPR = 0;  // Visual prime\n  int VTR = 1;  // Visual target\n  int VMK = 2;  // Visual mask\n  int VTRC = 3; // Visual target choice\n  int VFLC = 4; // Visual foil choice\n  \n  // Assignments for orthographic and semantic layers\n  int TARG = 0; // Target\n  int FOIL = 1; // Foil\n  \n  // Weight matrices\n  arma::mat VisOrth( 5, 2, arma::fill::zeros );\n  VisOrth( 0, 0 ) = primeInput(0);\n  VisOrth( 0, 1 ) = primeInput(1);\n  VisOrth( 1, 0 ) = 1.0;\n  VisOrth( 3, 0 ) = 1.0;\n  VisOrth( 4, 1 ) = 1.0;\n  \n  // Identity matrix for weights\n  arma::mat OrthSem(2,2,arma::fill::eye);\n  // Same identity matrix for feedback\n  arma::mat SemOrth(2,2,arma::fill::eye);\n  \n  \n  arma::mat out_sem( 1, 5, arma::fill::zeros );\n  for ( int pd = 0; pd < durations.size(); pd++ ) {\n    \n    // Extract prime durations\n    int PrimeDur = durations(pd);\n    // Determine time when choices are presented\n    int SOA = PrimeDur + TarDur + MaskDur;\n    // Duration of entire trial\n    int TrialDur = SOA + ChoiceDur;\n    \n    // Initialize neural variables\n    \n    // Visual layer\n    arma::mat mem_vis( 1, 5, arma::fill::zeros );\n    arma::mat amp_vis( 1, 5, arma::fill::ones );\n    arma::mat out_vis( 1, 5, arma::fill::zeros );\n    \n    // Orthographic layer\n    arma::mat mem_orth( 1, 2, arma::fill::zeros );\n    arma::mat amp_orth( 1, 2, arma::fill::ones );\n    arma::mat out_orth( 1, 2, arma::fill::zeros );\n    \n    // Semantic-lexical layer\n    arma::mat mem_sem( 1, 2, arma::fill::zeros );\n    arma::mat amp_sem( 1, 2, arma::fill::ones );\n    arma::mat out_sem( 1, 2, arma::fill::zeros );\n    \n    // Needed to check for peak output\n    arma::mat old_sem( 1, 2, arma::fill::zeros );\n    \n    // Initialize input\n    arma::mat inp_vis( 1, 5);\n    \n    // Update layers every ms\n    for ( int t = 1; t <= TrialDur; t++ ) {\n      \n      // Present prime\n      if ( t == 1 ) {\n        inp_vis.zeros();\n        inp_vis(0,VPR) = 1.0;\n      }\n      // Present target\n      if ( t == PrimeDur + 1 ) {\n        inp_vis.zeros();\n        inp_vis(0,VTR) = 1.0;\n      }\n      // Present mask\n      if ( t == PrimeDur + TarDur + 1 ) {\n        inp_vis.zeros();\n        inp_vis(0,VMK) = 1.0;\n      }\n      // Present choices\n      if ( t == SOA+1 ) {\n        inp_vis.zeros();\n        inp_vis(0,VTRC) = 1.0;\n        inp_vis(0,VFLC) = 1.0;\n      }\n      \n      // Update visual layer\n      arma::mat new_mem_vis( 1, 5, arma::fill::zeros );\n      arma::mat new_amp_vis( 1, 5, arma::fill::zeros );\n      update_nROUSE( new_mem_vis, new_amp_vis, out_vis, \n                     inp_vis, mem_vis, amp_vis, \n                     Th, L, R, D, I, S, 1 );\n      \n      // Determine input from visual layer\n      arma::mat inp_orth = out_vis*VisOrth;\n      inp_orth = inp_orth + Fe*( out_sem*SemOrth );\n      \n      // Update orthographic layer\n      arma::mat new_mem_orth( 1, 5, arma::fill::zeros );\n      arma::mat new_amp_orth( 1, 5, arma::fill::zeros );\n      update_nROUSE( new_mem_orth, new_amp_orth, out_orth, \n                     inp_orth, mem_orth, amp_orth, \n                     Th, L, R, D, I, S, 2 );\n      \n      // Determine input to lexical-semantic layer\n      arma::mat inp_sem = out_orth*OrthSem;\n      \n      // Update semantic-lexical layer\n      arma::mat new_mem_sem( 1, 5, arma::fill::zeros );\n      arma::mat new_amp_sem( 1, 5, arma::fill::zeros );\n      update_nROUSE( new_mem_sem, new_amp_sem, out_sem, \n                     inp_sem, mem_sem, amp_sem, \n                     Th, L, R, D, I, S, 3 );\n      \n      // Perceptual decision process\n      \n      // The +50 gives things a chance to get going before peak \n      // activation is checked\n      if ( t > SOA + 50 ) {\n        for ( int tf = 0; tf < 2; tf++ ) {\n          // Step through index for target and foil\n          if ( ( out_sem(tf) < old_sem(tf) ) && \n               ( Latency(pd,tf) == 0 ) ) {\n            // Check for peak activation\n            Latency(pd,tf) = t - SOA;\n          }\n        }\n        old_sem = out_sem;\n      }\n      \n      // Swap old variables with new variables\n      mem_vis = new_mem_vis;\n      amp_vis = new_amp_vis;\n      mem_orth = new_mem_orth;\n      amp_orth = new_amp_orth;\n      mem_sem = new_mem_sem;\n      amp_sem = new_amp_sem;\n      \n    }\n    \n    // Calculate accuracy\n    // Average difference between target and foil latency\n    double mean_diff = Latency(pd,FOIL) - Latency(pd,TARG);\n    // Variance of difference between target and foil latency\n    double var_diff = accu( exp( N * Latency.row(pd) ) );\n    \n    acc(pd) = 1.0 - R::pnorm( 0.0, mean_diff, pow(var_diff,0.5), 1, 0 );\n    \n    if ( ( Latency(pd,TARG) == 0 ) && \n         ( Latency(pd,FOIL) > 0 ) ) {\n      // Target never launched\n      acc(pd) = 0.0;\n    }\n    if ( ( Latency(pd,TARG) > 0 ) && \n         ( Latency(pd,FOIL) == 0 ) ) {\n      // Foil never launched\n      acc(pd) = 1.0;\n    }\n    if ( ( Latency(pd,TARG) == 0 ) && \n         ( Latency(pd,FOIL) == 0 ) ) {\n      // Neither launched\n      acc(pd) = 0.5;\n    }\n    \n  }\n  \n  // Create a list of output\n  return Rcpp::List::create( \n    Rcpp::Named(\"Latency\", Latency ),\n    Rcpp::Named(\"Accuracy\", acc ) );\n}",
    "created" : 1471144348519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2063885816",
    "id" : "6261030F",
    "lastKnownWriteTime" : 1471219604,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/nROUSE/src/nROUSE_functions.cpp",
    "project_path" : "src/nROUSE_functions.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "cpp"
}