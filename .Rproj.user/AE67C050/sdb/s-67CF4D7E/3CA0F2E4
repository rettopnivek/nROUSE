{
    "contents" : "#------------------------------------#\n# R code for implementing the nROUSE #\n# model (Huber and O'Reilly, 2003)   #\n#------------------------------------#\n\n# Assignments for visual layer\n\nVPR = 1;  # Visual prime\nVTR = 2;  # Visual target\nVMK = 3;  # Visual mask\nVTRC = 4; # Visual target choice\nVFLC = 5; # Visual foil choice\n\n# Assignments for orthographic and semantic layers\n\nTARG = 1; # Target\nFOIL = 2; # Foil\n\n# Weight matrices\n\nVisOrth = rbind(\n  c( 0, 0 ), # From VPR\n  c( 1, 0 ), # From VTR\n  c( 0, 0 ), # From VMK\n  c( 1, 0 ), # From VTRC\n  c( 0, 1 )  # From VFLC\n)\nOrthSem = diag(2); # Identity matrix for weights\nSemOrth = diag(2); # Same identity matrix for feedback\n\n# Experimental procedures\n\nTarDur = 50; # Duration of target flash (ms)\nMaskDur = 500 - TarDur; # Duration of target mask\nChoiceDur = 500; # Duration of choice display\ndurations = c( 17,50,150,400,2000 ) # Prime durations\n\n# Parameters\n\nFe = .25;           # Semantic to orthographic feedback scalar\nN = 0.0302;         # Noise constant\nL = .15;            # Constant leak current\nD = .324;           # Synaptic depletion rate\nR = .022;           # Recovery rate\nI = 0.9844;         # Inhibition constant\nTh = .15;           # Activation threshold\nS = c( S1 = 0.0294, \n       S2 = 0.0609, \n       S3 = .015 ); # Integration time constants at each level\n\nmy_subplus = function( x ) {\n  \n  x[ x <= 0 ] = 0;\n  return( x )\n  \n}\n\nnROUSE_update = function( old_mem, old_amp, inp, level ) {\n  # Purpose:\n  # Forthcoming\n  # Arguments:\n  # old_mem -\n  # old_amp -\n  # inp     -\n  # level   -\n  # Returns:\n  # Forthcoming\n  \n  # Output is above threshold activation multiplied by available \n  # synaptic resources\n  old_out = my_subplus( old_mem - Th ) * old_amp;\n  \n  inhibit = numeric(ncol(old_out))\n  if ( level == 1 ) { # Visual inhibition\n    \n    # Prime, target, and mask mutually inhibit each other \n    # (centrally presented)\n    inhibit[1:3] = rep( sum( old_out[1,1:3] ), 3 );\n    # Choice words only self inhibit (unique screen location)\n    inhibit[4:5] = old_out[1,4:5];\n  } else {\n    # For orthography and semantics, everything inhibits everything\n    inhibit = rep( sum(old_out), ncol(old_out) );\n  }\n  \n  # Update membrane potential and synaptic resources\n  new_mem = old_mem + ( S[level]*(  ( inp*(1 - old_mem) )  -  \n                                      (L*old_mem)  -  \n                                      (I*inhibit*old_mem) ) );\n  new_amp = old_amp + ( S[level]*(  (  R*(1 - old_amp) )  -  \n                                      (D*old_out) ) );\n  new_mem[new_mem<0] = 0; # Keep things within bounds\n  new_mem[new_mem>1] = 1;\n  new_amp[new_amp<0] = 0;\n  new_amp[new_amp>1] = 1;\n  \n  return( list( new_mem, new_amp, old_out ) )\n}\n\n\nnROUSE_simulate = function() {\n  \n  Latency = matrix( 0, length( durations ), 2 )\n  acc = numeric( length( durations ) )\n  \n  for (pd in 1:length( durations ) ) {\n    \n    # Extract prime duration\n    PrimeDur = durations[pd];\n    # Determine time when choices are presented\n    SOA = PrimeDur + TarDur + MaskDur;\n    # Total duration of the trial\n    TrialDur = SOA + ChoiceDur;\n    \n    # Initialize neural variables\n    mem_vis  = matrix( 0, 1, 5 );\n    amp_vis  = matrix( 1, 1, 5 );\n    out_vis  = matrix( 0, 1, 5 );\n    mem_orth = matrix( 0, 1, 2 );\n    amp_orth = matrix( 1, 1, 2 );\n    out_orth = matrix( 0, 1, 2 );\n    mem_sem  = matrix( 0, 1, 2 );\n    amp_sem  = matrix( 1, 1, 2 );\n    out_sem  = matrix( 0, 1, 2 );\n    old_sem  = matrix( 0, 1, 2 ); # Needed to check for peak output\n    \n    for ( t in 1:TrialDur ) {\n      \n      # Determine input into visual layer\n      \n      # Present prime\n      if ( t == 1 ) {\n        inp_vis = matrix( 0, 1, 5 );\n        inp_vis[1,VPR] = 1;\n      }\n      # Present target\n      if ( t == PrimeDur + 1 ) {\n        inp_vis = matrix( 0, 1, 5 );\n        inp_vis[1,VTR] = 1;\n      }\n      # Present mask\n      if ( t == PrimeDur + TarDur + 1 ) {\n        inp_vis = matrix( 0, 1, 5 );\n        inp_vis[1,VMK] = 1;\n      }\n      # Present choices\n      if ( t == SOA+1 ) {\n        inp_vis = matrix( 0, 1, 5 );\n        inp_vis[1,VTRC] = 1;\n        inp_vis[1,VFLC] = 1;\n      }\n      \n      # Update visual layer\n      out = nROUSE_update( mem_vis, amp_vis, inp_vis, 1 )\n      new_mem_vis = out[[1]];\n      new_amp_vis = out[[2]];\n      out_vis = out[[3]];\n      \n      # Determine input from visual layer\n      inp_orth = out_vis %*% VisOrth;\n      inp_orth = inp_orth + Fe*( out_sem %*% SemOrth );\n      \n      # Update orthographic layer\n      out = nROUSE_update( mem_orth, amp_orth, inp_orth, 2 )\n      new_mem_orth = out[[1]];\n      new_amp_orth = out[[2]];\n      out_orth = out[[3]];\n      \n      # Determine input to lexical-semantic layer\n      inp_sem = out_orth %*% OrthSem;\n      \n      # Update semantic layer\n      out = nROUSE_update( mem_sem, amp_sem, inp_sem, 3 )\n      new_mem_sem = out[[1]];\n      new_amp_sem = out[[2]];\n      out_sem = out[[3]];\n      \n      # Perceptual decision process\n      \n      # The +50 gives things a chance to get going before peak \n      # activation is checked\n      if ( t > SOA + 50 ) {\n        for ( tf in 1:2 ) {\n          # Step through index for target and foil\n          if ( out_sem[tf] < old_sem[tf] & Latency[pd,tf] == 0 ) {\n            # Check for peak activation\n            Latency[pd,tf] = t - SOA;\n          }\n        }\n        old_sem = out_sem;\n      }\n      \n      # Swap old variables with new variables\n      mem_vis = new_mem_vis;\n      amp_vis = new_amp_vis;\n      mem_orth = new_mem_orth;\n      amp_orth = new_amp_orth;\n      mem_sem = new_mem_sem;\n      amp_sem = new_amp_sem;\n      \n    }\n    \n    # Calculate accuracy\n    \n    # Average difference between target and foil latency\n    mean_diff = Latency[pd,FOIL] - Latency[pd,TARG];\n    # Variance of difference between target and foil latency\n    var_diff = sum( exp(N * Latency[pd,]) );\n    \n    acc[pd] = 1 - pnorm( 0, mean_diff, sqrt( var_diff ) );\n    \n    if ( Latency[pd,TARG] == 0 & Latency[pd,FOIL] > 0 ) {\n      # Target never launched\n      acc[pd] = 0;\n    }\n    if ( Latency[pd,TARG] > 0 & Latency[pd,FOIL] == 0 ) { \n      # Foil never launched\n      acc[pd] = 1;\n    }\n    if ( Latency[pd,TARG] == 0 & Latency[pd,FOIL] == 0 ) {\n      # Neither launched\n      acc[pd]=.5;\n    }\n    \n  }\n  \n  return( list( Latency = Latency, Acc = acc ) )\n}\n\n### Test code ###\n\nstartTime = Sys.time()\n\ntarget_lat = matrix( NA, length(durations), 2 )\nfoil_lat = matrix( NA, length(durations), 2 )\nacc = matrix( NA, length(durations), 2 )\n\nfor (cd in 1:2) {\n  if ( cd == 1 ) { # Target primed\n    # Set to 2 because there are two visual copies onscreen\n    VisOrth[VPR,] = c(2,0)\n  }\n  if ( cd == 2 ) { # Foil primed\n    VisOrth[VPR,] = c(0,2)\n  }\n  tst = nROUSE_simulate()\n  target_lat[,cd] = tst$Latency[,TARG]\n  foil_lat[,cd] = tst$Latency[,FOIL]\n  acc[,cd] = tst$Acc\n}\n\nR_res = list( target_lat, foil_lat, acc );\n\nendTime = Sys.time() - startTime\nprint( endTime )\n\nprint( target_lat )\nprint( foil_lat )\nprint( round( acc, 4 ) )",
    "created" : 1471202648074.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "230574148",
    "id" : "3CA0F2E4",
    "lastKnownWriteTime" : 1471219218,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/Initial_conversion.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}